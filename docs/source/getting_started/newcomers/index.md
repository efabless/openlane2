# Newcomers

VLSI, or Very Large-Scale Integration, is a cornerstone technology driving the
modern world, silently powering the devices we rely on daily. Its importance
stems from its profound impact on various aspects of our lives, making it
ubiquitous. VLSI facilitated the fabrication of chips. A chip is a small piece
of semiconductor material (usually silicon) containing integrated circuits.
These circuits consist of millions or even billions of tiny switches called
transistors and other electronic components that process information and perform
various functions. These chips are the brains behind countless electronic
devices, from smartphones and computers to cars and medical equipment.

One class of chips is called ASIC, or (Application-Specific Integrated Circuits.
ASIC is a type of chip custom-designed for a specific purpose, unlike
general-purpose chips like microprocessors that can be used for various tasks.
One of the most prominent examples of ASIC is smartphone processors. These chips
are custom-designed for mobile devices, focusing on low power consumption and
high performance for running apps, gaming, and streaming media. They often
incorporate specialized cores for graphics processing, artificial intelligence,
and image signal processing.

Designing an ASIC is a complex and fascinating process that entails various steps, from idea to the fabrication data. This process is filled with engineering challenges that require expertise and attention to detail. The entire process requires significant expertise and experience in chip design and can take several months to complete. The ASIC design flow is crucial to ensure successful ASIC design. It is based on a comprehensive understanding of ASIC specifications, requirements, low-power design, and performance. Engineers can streamline the process and meet crucial time-to-market goals by following a proven ASIC design flow. Each stage of the ASIC design cycle is supported by powerful EDA (Electronic Design Automation) tools that facilitate the implementation of the design. The following are examples of steps needed to realize an ASIC. 
* Design Entry: In this step, the logic design is described using a Hardware
Description Language (HDL) like System Verilog. Typically, the description is
done at the data flow (Register Transfer) or behavioral levels. 
* Functional Verification: It is essential to catch design errors early on.
The description must be checked against the requirements, which can be done
through simulation or formal methods. Functional verification is performed on
the RTL description as well as the netlists generated by the following steps.
* Synthesis: In this step, the HDL description is converted into a circuit of
the logic cells called the Netlist.
* Layout/Physical Synthesis: Also called Physical Implementation. In this
step, the logic circuit is converted into a layout of the photo masks used for
fabrication. This complex step involves several sub-steps typically automated
using its flow. These steps include Floorplanning, Placement, Clock-tree
synthesis and Routing. Because Placement and Routing are the most time-consuming
operations, sometimes we refer to this step as "Placement and Routing", or PnR. 
* Signoff: marks the final stage in the rigorous journey of an ASIC's design;
it ensures your creation functions flawlessly, operates efficiently, and
ultimately delivers on its promise before sending your chip blueprint off to be
carved in silicon.

Please note that the five mentioned steps are the major ones. There are several
other design steps that are not mentioned here such as scan chain insertion and
test patterns generations that are essential to testing the fabricated chip
against fabrication defects.

What is OpenLane?

## What is OpenLane?

```{figure} ./flow.png
:scale: 30 %
:align: right

OpenLane Flow
```

OpenLane is a powerful and versatile infrastructure library that enables the construction of digital ASIC physical implementation flows based on open-source and commercial EDA tools. It includes a reference flow (Classic) that is constructed entirely using open-source EDA tools –abstracting their behavior and allowing the user to configure them using a single file (See Figure 1). OpenLane also supports extending or modifying the flow using Python scripts and utilities. Here are some of the key benefits of using OpenLane:
* Flexibility and extensibility: OpenLane is designed to be flexible and extensible, allowing designers to customize the flow to meet their specific needs by developing Python scripts (plugins) and utilities or by modifying the existing configuration file.
* Open source: OpenLane is an open-source project that is freely available to use and modify, which makes it a good choice for designers looking for a transparent, cost-effective solution.
* Community support: OpenLane capitalizes on OpenLane's existing community of users and contributors, which means that a wealth of resources is available to help designers get started and troubleshoot any problems they encounter.

```{seealso}
You may want to check out [OpenLane using Google Colab directly in your browser](https://developers.google.com/silicon/guides/digital-inverter-openlane).

It's free, and there's no need to install anything on your machine!
```

```{note}
This guide assumes that the reader has some basic knowledge of Digital Design,
{term}`ASIC`, the JSON format and {term}`RTL`.
```

---

## Installation

1. Follow the instructions [here](https://app.cachix.org/cache/openlane) to
   install {term}`Nix` and set up {term}`Cachix`.

1. Open a terminal and clone OpenLane as follows:

   ```console
   $ git clone https://github.com/efabless/openlane2/ ~/openlane2
   ```

1. Invoke `nix-shell`, which will make all the packages bundled with OpenLane
   available to your shell.

   ```console
   $ nix-shell --pure ~/openlane2/shell.nix
   ```

   Some packages will be downloaded (about 3GiB) and afterwards the terminal
   prompt should change to:

   ```console
   [nix-shell:~/openlane2]$
   ```

   ```{admonition} Important
   :class: tip

   From now on; all commands assume that you are inside the `nix-shell`.
   ```

1. Run the smoke test to ensure everything is fine. This also downloads
   {term}`sky130` {term}`PDK`.

   ```console
   [nix-shell:~/openlane2]$ openlane --log-level ERROR --condensed --show-progress-bar --smoke-test
   ```

That's it. Everything is ready. Now, let's try OpenLane.

---

## Running the default flow

### SPM example

We are going to use a simple design: a serial-by-parallel signed 32-bit
multiplier `SPM` as shown in the first figure of
[this paper](https://doi.org/10.1109/ACSSC.1993.342534).

This multiplier performs a simple shift-add algorithm, where the parallel input
`a` is multiplied by each bit of the serial input `x` as it is shifted in. The
product is generated and serially output on the wire `y`.

Typically, an SPM is interfaced with 3 registers. One parallel register to
provide the multiplier, and two shift registers to provide the multiplicand and
to receive the serial product (64-bit).

```{figure} ./spm-block-diagram.png
:scale: 60 %
:align: center

SPM (Serial-by-Parallel Multiplier)
```

#### RTL

This is the source {term}`RTL` of the design.

````{dropdown} spm.v

```{literalinclude} ../../../../openlane/examples/spm/src/spm.v
:language: verilog
```
````

#### Configuration

Designs in OpenLane have configuration files. A configuration file contains
values set by the user for various {py:class}`openlane.config.Variable`(s).
With them, you control the OpenLane flow. This is the configuration file for the
`spm` design:

````{dropdown} config.json

```json
{
  "DESIGN_NAME": "spm",
  "VERILOG_FILES": "dir::spm.v",
  "CLOCK_PERIOD": 10,
  "CLOCK_PORT": "clk"
}
```

````



```{warning}
(required-variables)=
For any design, at a minimum you need to specify the following variables:
* {var}`::DESIGN_NAME`
* {var}`Yosys.Synthesis::VERILOG_FILES`
* {var}`::CLOCK_PERIOD`
* {var}`::CLOCK_PORT`
```

```{seealso}
Check out {flow}`the Classic flow's documentation <Classic>` for information about
all available variables.
```

#### How to run?

1. Create a directory to add our source files to:

   ```console
   [nix-shell:~/openlane2]$ mkdir -p ~/my_designs/spm
   ```

1. Create the file `~/my_designs/spm/config.json` and add
   [configuration](#configuration) content to it.

1. Create the file `~/my_designs/spm/spm.v` and add [RTL](#rtl) content to it.

1. Run the following command:

   ```console
   [nix-shell:~/openlane2]$ openlane ~/my_designs/spm/config.json
   ```

````{tip}
Double-checking: are you inside a `nix-shell`? Your terminal prompt
should look like this:

```console
[nix-shell:~/openlane2]$
```

If not, enter the following command in your terminal:

```console
$ nix-shell --pure ~/openlane2/shell.nix
```
````

---

### Checking the results

#### Viewing the Layout

To open the final {term}`GDSII` layout run this command:

```console
[nix-shell:~/openlane2]$ openlane --last-run --flow openinklayout ~/my_designs/spm/config.json
```

This opens {term}`KLayout` and you should be able to see the following:

```{figure} ./spm-gds.png
:align: center
```

If you wish to view the layout in the {term}`OpenROAD` GUI, try this command
instead:

```console
[nix-shell:~/openlane2]$ openlane --last-run --flow openinopenroad ~/my_designs/spm/config.json
```

---

#### Run directory

You'll find that a **run directory** (named something like
`runs/RUN_2023-12-27_16-59-15`) was created when you ran OpenLane.

By default, OpenLane runs a {py:class}`Flow <openlane.flows.Flow>` composed of a sequence of
{py:class}`Step <openlane.steps.Step>`(s). Each step has its separate directory within the run
directory.

For example, the {step}`OpenROAD.TapEndCapInsertion` Step creates the following
directory `14-openroad-tapendcapinsertion`.

A step directory has log files, report files, {term}`metrics` and output
artifacts created by the step.

For example, these are the contents of `14-openroad-tapendcapinsertion`:

```text
14-openroad-tapendcapinsertion/
├── COMMANDS
├── config.json
├── openroad-tapendcapinsertion.log
├── openroad-tapendcapinsertion.process_stats.json
├── or_metrics_out.json
├── spm.def
├── spm.nl.v
├── spm.odb
├── spm.pnl.v
├── spm.sdc
├── state_in.json
└── state_out.json
```

Here is a small description of each of those files:
`````{dropdown} Directory of contents

* `COMMANDS`: any commands run by the step
* `config.json`: a configuration file with all variables accessible by this Step
* `*.log`: log files of subprocesses run by the step
* `*.process_stats.json`: statistics about total elapsed time and resource
  consumption of subprocesses
* `state_in.json`: contains a dictionary of design layout formats (such as {term}`DEF`
  files) and design metrics available as inputs to a step
* `state_out.json`: contains the value `state_out.json` after updates by the step-
  e.g. if a step generates a new DEF file, it would be updated in `state_out.json`.
* `spm.nl.v`: A Verilog gate-level netlist generated by the step **without**
  power connections
* `spm.pnl.v`: A Verilog gate-level netlist generated by the step **with**
  power connections
* `spm.odb`: The current state of the layout saved in the OpenROAD database format
* `spm.def`: The current state of the layout saved in the DEF format
* `spm.sdc`: Current constraints on the design saved in the {term}`SDC` format.

````{tip}
Using `state_out.json`, you can view the layout at intermediate steps as well!

```console
[nix-shell:~/openlane2]$ openlane --last-run --flow openinklayout ~/my_designs/spm/config.json --with-initial-state ~/my_designs/spm/runs/RUN_2023-12-27_16-59-15/14-openroad-tapendcapinsertion/state_out.json"
```
````

`````

The run directory is composed of many of these step directories:

```text
RUN_2023-12-27_16-59-15
├── 01-verilator-lint/
├── 02-checker-linttimingconstructs/
├── 03-checker-linterrors/
├── 04-yosys-jsonheader/
├── 05-yosys-synthesis/
├── 06-checker-yosysunmappedcells/
├── 07-checker-yosyssynthchecks/
├── 08-openroad-checksdcfiles/
├── 09-openroad-staprepnr/
├── 10-openroad-floorplan/
├── 11-odb-setpowerconnections/
├── 12-odb-manualmacroplacement/
├── 13-openroad-cutrows/
├── 14-openroad-tapendcapinsertion/
├── 15-openroad-globalplacementskipio/
⋮
├── final/
├── tmp
├── error.log
├── info.log
├── resolved.json
└── warning.log
```

#### Final Results

Inside the run directory, you may have noticed there is another, non-step
specific folder named `final`.

`final` contains a number of directories that contain all the different layout
views produced by the flow. It looks like this:

```text
final
├── def/
├── gds/
├── json_h/
├── klayout_gds/
├── lef/
├── lib/
├── mag/
├── mag_gds/
├── nl/
├── odb/
├── pnl/
├── sdc/
├── sdf/
├── spef/
├── spice/
├── metrics.csv
└── metrics.json
```

Moreover, it contains `metrics.csv` and `metric.json` which represent the final
metrics in `JSON` and {term}`CSV` formats.

---

### Signoff Steps

An ASIC design’s signoff is the last phase of its implementation. It involves
physical and timing verifications before committing to the silicon manufacturing
process, which is commonly known as "design tape-out".

OpenLane runs a couple of Step(s) for the final signoff.

1. [DRC](#drc)
1. [LVS](#lvs)
1. [STA](#sta)
1. [Antenna Check](#antenna-check)

#### DRC

{term}`DRC` stands for Design Rule Checking which checks, against rules set by chip foundries
, that the layout has to satisfy in order to be manufacturable,
such as checking for minimum allowed spacing between two `met1` shapes.

OpenLane runs two DRC steps using `Magic` and `KLayout`: {step}`Magic.DRC` and
`KLayout.DRC`. Both tools have blind spots that are covered by the other tools.

Both the layout and what is known as a PDK's {term}`DRC deck` are processed by
the tools running DRC, as shown in the diagram below:

```{figure} ./OL-DRC.png
:align: center
:scale: 50 %

DRC (Design Rule Checking) Flow
```

If DRC violations are found; OpenLane will generate an error reporting the total
count of violations found by each Step.

To view DRC errors graphically, you may open the layout as follows:

```console
[nix-shell:~/openlane2]$ openlane --last-run --flow openinklayout ~/my_designs/spm/config.json
```

Then in the menu bar select Tools ► Marker Browser. A new window should open.

```{figure} ./klayout-markerbrowser-menu.png
:align: center
```

Click File ► Open and then select the DRC report file, of which you'll find two:
One under `52-magic-drc/reports/drc.klayout.xml` and the other under
`53-klayout-drc/report/drc.klayout.xml`.

```{tip}
The initial number in `53-klayout-drc` (`53`) may vary according to the
flow's configuration.
```

```{figure} ./klayout-markerbrowser-menu-2.png
:align: center
```

#### LVS

{term}`LVS` stands for Layout Versus Schematic. It compares the layout {term}`GDSII`
or DEF/LEF, with the schematic which is usually in {term}`Verilog`, ensuring
that connectivity in both views are matching. Sometimes, user configuration or
even the tools have errors and such check is important to catch them.

Common LVS errors include but are not limited to:

- Shorts: Two or more wires that should not be connected have been and must be
  separated. The most problematic is power and ground shorts.
- Opens: Wires or components that should be connected are left dangling or only
  partially connected. These must be connected properly.
- Missing Components: An expected component has been left out of the layout.

`Netgen.LVS` is the Step ran for LVS using a tool called {term}`Netgen`.
First, the layout is converted to {term}`SPICE netlist`. Next, the layout and
the schematic are inputted to Netgen, as shown in the diagram below:

```{figure} ./OL-LVS.png
:scale: 50 %
:align: center

LVS (Layout-versus-Schematic) Flow
```

`Netgen` will generate multiple files that can be browsed in case of LVS
errors. As all Step(s), these will be inside the Step's directory.

You would want to look at `netgen-lvs.log` which has a summary of the results of
`LVS`. Ideally, you would find the following at the end of this log file:

```text
Final result:
Circuits match uniquely.
```

In case of errors, there is also `lvs.rpt` which is more detailed. Inside it,
you will find tables comparing nodes between the layout and the schematic. On
the left is the layout (`GDS`) and the schematic  Verilog) is on the other
side. Here is a sample of these tables:

```text
Subcircuit summary:
Circuit 1: spm                             |Circuit 2: spm
-------------------------------------------|-------------------------------------------
sky130_fd_sc_hd__tapvpwrvgnd_1 (102->1)    |sky130_fd_sc_hd__tapvpwrvgnd_1 (102->1)
sky130_fd_sc_hd__decap_3 (144->1)          |sky130_fd_sc_hd__decap_3 (144->1)
sky130_fd_sc_hd__inv_2 (64)                |sky130_fd_sc_hd__inv_2 (64)
sky130_fd_sc_hd__nand2_1 (31)              |sky130_fd_sc_hd__nand2_1 (31)
sky130_fd_sc_hd__dfrtp_1 (64)              |sky130_fd_sc_hd__dfrtp_1 (64)
sky130_ef_sc_hd__decap_12 (132->1)         |sky130_ef_sc_hd__decap_12 (132->1)
```

#### STA

STA stands for Static Timing Analysis. The STA tool identifies the design
timing paths and then calculates the data earliest and latest actual and
required arrival times at every timing path endpoint. If the data arrives after
(in case of setup checking) or before (hold checking) it is required, then we
have a timing violation (negative slack). STA makes sure that a circuit will
correctly perform its function (but tells nothing about the correctness of
that function.)

```{figure} ./STA.png
:align: center
:scale: 50 %

STA (Static Timing Analysis) Flow
```

The default flow runs as step called {step}`OpenROAD.STAPostPNR` for STA signoff.

```{note}
During the flow the step {step}`OpenROAD.STAMidPNR` is ran multiple times 
The results are not as accurate as `OpenRAOD.STAPostPNR` since the design 
is not fully implemented yet. However, they provide a better sense of the impact
multiple stages of the flow (such as optimizations steps) on STA results for the
design.
```

Inside the Step directory there is a file called `summary.rpt` which
summarizes important metrics for each {term}`IPVT` {term}`timing corner`:

```text
┏━━━━━━━━━━━━━┳━━━━━━━━━━━━━┳━━━━━━━━━━━━━┳━━━━━━━━━━━━━┳━━━━━━━━━━━━━┳━━━━━━━━━━━━━┳━━━━━━━━━━━━━┳━━━━━━━━━━━━━┳━━━━━━━━━━━━┓
┃             ┃ Hold Worst  ┃ Hold        ┃ of which    ┃ Setup Worst ┃ Setup       ┃ of which    ┃ Max Cap     ┃ Max Slew   ┃
┃ Corner/Gro… ┃ Slack       ┃ Violations  ┃ reg-to-reg  ┃ Slack       ┃ Violations  ┃ reg-to-reg  ┃ Violations  ┃ Violations ┃
┡━━━━━━━━━━━━━╇━━━━━━━━━━━━━╇━━━━━━━━━━━━━╇━━━━━━━━━━━━━╇━━━━━━━━━━━━━╇━━━━━━━━━━━━━╇━━━━━━━━━━━━━╇━━━━━━━━━━━━━╇━━━━━━━━━━━━┩
│ Overall     │ 0.1115      │ 0           │ 0           │ 5.9742      │ 0           │ 0           │ 0           │ 0          │
│ nom_tt_025… │ 0.3308      │ 0           │ 0           │ 6.8067      │ 0           │ 0           │ 0           │ 0          │
│ nom_ss_100… │ 0.9046      │ 0           │ 0           │ 5.9894      │ 0           │ 0           │ 0           │ 0          │
│ nom_ff_n40… │ 0.1127      │ 0           │ 0           │ 7.1209      │ 0           │ 0           │ 0           │ 0          │
│ min_tt_025… │ 0.3293      │ 0           │ 0           │ 6.8173      │ 0           │ 0           │ 0           │ 0          │
│ min_ss_100… │ 0.9046      │ 0           │ 0           │ 6.0068      │ 0           │ 0           │ 0           │ 0          │
│ min_ff_n40… │ 0.1115      │ 0           │ 0           │ 7.1289      │ 0           │ 0           │ 0           │ 0          │
│ max_tt_025… │ 0.3324      │ 0           │ 0           │ 6.7966      │ 0           │ 0           │ 0           │ 0          │
│ max_ss_100… │ 0.9072      │ 0           │ 0           │ 5.9742      │ 0           │ 0           │ 0           │ 0          │
│ max_ff_n40… │ 0.1138      │ 0           │ 0           │ 7.1133      │ 0           │ 0           │ 0           │ 0          │
└─────────────┴─────────────┴─────────────┴─────────────┴─────────────┴─────────────┴─────────────┴─────────────┴────────────┘
```

There is also a directory per corner inside the Step directory which contains
all the log files and reports generated for each `IPVT corner`.

```text
45-openroad-stapostpnr/
└── nom_tt_025C_1v80/
    ├── checks.rpt
    ├── filter_unannotated.log
    ├── filter_unannotated.process_stats.json
    ├── filter_unannotated_metrics.json
    ├── max.rpt
    ├── min.rpt
    ├── power.rpt
    ├── skew.max.rpt
    ├── skew.min.rpt
    ├── spm__nom_tt_025C_1v80.lib
    ├── spm__nom_tt_025C_1v80.sdf
    ├── sta.log
    ├── sta.process_stats.json
    ├── tns.max.rpt
    ├── tns.min.rpt
    ├── violator_list.rpt
    ├── wns.max.rpt
    ├── wns.min.rpt
    ├── ws.max.rpt
    └── ws.min.rpt
```

Here is a small description of each file:

- `sta.log`: Full log file generated by STA which is divided into the
  following report files

- `min.rpt`: Constrained paths for hold checks.

- `max.rpt`: Constrained paths for setup checks.

- `skew.min.rpt`: Maximum clock skew for hold checks.

- `skew.max.rpt`: Maximum clock skew for setup checks.

- `tns.min.rpt`: Total negative hold slack.

- `tns.max.rpt`: Total negative setup slack.

- `wns.min.rpt`: Worst negative hold slack.

- `wns.max.rpt`: Worst negative setup slack.

- `ws.min.rpt`: Worst hold slack.

- `ws.max.rpt`: Worst setup slack.

- `violator_list.rpt` Setup and hold violator endpoints.

- `checks.rpt`: It contains a summary of the following checks:

  1. Max capacitance violations
  1. Max slew violations
  1. Max fanout violations
  1. Unconstrained paths
  1. Unannotated and partially annotated nets
  1. Checks the SDC for combinational loops, register/latch with multiple
     clocks or no clocks, ports missing input delay, and generated clocks
  1. Worst setup or hold violating path

```{seealso}
Check out our [STA and timing closure guide](https://docs.google.com/document/d/13J1AY1zhzxur8vaFs3rRW9ZWX113rSDs63LezOOoXZ8/)
for a deeper dive into what you can do to achieve timing closure when violations
actually occur.
```

#### Antenna Check

Long metal wire segments that are connected to a transistor gate may damage the
transistor thin gate oxide during the fabrication process due its collection of
charges from the processing environment. This is called the antenna effect
(Also, called Plasma Induced Gate Oxide Damage). Chip foundries normally supply
antenna rules, which are rules that must be obeyed to avoid this problem. The
rules limit the ratio of collection area and drainage (thin oxide) area. Antenna
effect can be avoided by instructing the router to use short wire segments and
to create bridges to disconnect long from transistor gates during fabrication.
This approach is not used by OpenLane as OpenROAD routers don't support this
methodology. Instead, OpenLane uses another approach that involves the insertion
of an antenna diode (provided as a standard cell) next to the cell input pin
that suffers from the antenna effect. Antenna diode cell has a reversed biased
diode which can drain out the charge without affecting the transistor circuitry.


```{figure} ./antenna-effect.png

Antenna effect
```

```{figure} ./antenna-diode.png

Antenna diode insertion
```

The default flow runs a step called {step}`OpenROAD.CheckAntennas` to check for
antenna rules violations.

```{note}
The checker runs thrice during the flow:
1. Once immediately after global routing
2. Once as part of the {step}`OpenROAD.RepairAntennas` composite step
3. During signoff

First two are ran to see the impact of antenna repair step.
```

Inside the step directory of `OpenROAD.CheckAntennas` there is a `reports`
directory which contains two files on has the full antenna check report from
`OpenROAD` and a summary table of antenna violations:

```text
┏━━━━━━━━━━━━━━━━━━┳━━━━━━━━━━┳━━━━━━━━━┳━━━━━━━━┳━━━━━━━━━━━━━┳━━━━━━━┓
┃ Partial/Required ┃ Required ┃ Partial ┃ Net    ┃ Pin         ┃ Layer ┃
┡━━━━━━━━━━━━━━━━━━╇━━━━━━━━━━╇━━━━━━━━━╇━━━━━━━━╇━━━━━━━━━━━━━╇━━━━━━━┩
│ 1.43             │ 400.00   │ 573.48  │ net162 │ output162/A │ met3  │
│ 1.28             │ 400.00   │ 513.90  │ net56  │ _1758_/A1   │ met3  │
└──────────────────┴──────────┴─────────┴────────┴─────────────┴───────┘
```

---

### SPM as a macro for [Caravel](https://caravel-harness.readthedocs.io/en/latest/)

Often a design by itself serves no purpose unless interfaced with and/or
integrated into another design or a chip. We are going to harden the `spm`
design again but this time we will have it as a
[Caravel User Project](https://caravel-user-project.readthedocs.io/en/latest/)
macro for the chip [Caravel](https://caravel-harness.readthedocs.io/en/latest/)

```{admonition} About Caravel
:class: seealso

The Efabless Caravel chip is a ready-to-use test harness for creating designs
with the Google/Skywater 130nm Open PDK. The Caravel harness comprises of base
functions supporting IO, power, and configuration as well as drop-in modules for
a management SoC core, and an approximately 3000um x 3600um open project area
for the placement of user IP blocks.

Check [Caravel](https://caravel-harness.readthedocs.io/en/latest/) for more
information.
```

#### RTL updates

We begin by updating the RTL needed for integration of the spm into Caravel.

1. Create a new directory `~/my_designs/spm-user_project_wrapper/` and

   ```console
   [nix-shell:~/openlane2]$ mkdir -p ~/my_designs/spm-user_project_wrapper
   ```

1. Add the following new RTL to
   `~/my_designs/spm-user_project_wrapper/SPM_example.v`:

   ````{dropdown} SPM_example.v

   ```{literalinclude} ../../../../openlane/examples/spm-user_project_wrapper/SPM_example.v

   ```

   ````

1. Also add `~/my_designs/spm-user_project_wrapper/user_project_wrapper.v`:

   ````{dropdown} user_project_wrapper

   ```{literalinclude} ../../../../openlane/examples/spm-user_project_wrapper/user_project_wrapper.v

   ```

   ````

1. Finally, we need an additional file
   `~/my_designs/spm-user_project_wrapper/defines.v` which is required by
   Caravel User Project.

   ````{dropdown} defines.v

   ```{literalinclude} ../../../../openlane/examples/spm-user_project_wrapper/defines.v
   ```

   ````

```{seealso}
Check out
[Caravel User Project's documentation on Verilog Integration](https://caravel-user-project.readthedocs.io/en/latest/#verilog-integration)
for information about the changes that were done to the RTL.
```

(configuration-user-project-wrapper)=
#### Configuration

Then we need to create a configuration file to pass to the flow. OpenLane has
an interactive tool to do just that:

```console
[nix-shell:~/my_designs/spm-user_project_wrapper]$ openlane.config create-config
Please input the file name for the configuration file [config.json]: config.json
Enter the base directory for your design [.]: .
Enter the design name (which should be equal to the HDL name of your top module): user_project_wrapper
Enter the name of your design's clock port: wb_clk_i
Enter your desired clock period in nanoseconds: 25
Input the RTL source file #0 (Ctrl+D to stop): defines.v
Input the RTL source file #1 (Ctrl+D to stop): SPM_example.v
Input the RTL source file #2 (Ctrl+D to stop): user_project_wrapper.v
```

#### Running the flow

Let's try running the flow:

```console
[nix-shell:~/openlane2]$ openlane ~/my_designs/spm-user_project_wrapper/config.json
```

#### Addressing issues

The flow will fail with the following message:

```text
[ERROR PPL-0024] Number of IO pins (637) exceeds maximum number of available positions (220).
Error: ioplacer.tcl, 56 PPL-0024
```

The reason that happens is that when we change the RTL of the design we
changed the IO pin interface of the design to match the interface needed by
Caravel User Project.

Caravel User Project needs a lot of IO pins. By default, the flow will
attempt to create a floorplan using a utilization of 50%. Relative to the cells
in the design, there are too many IO pins to fit in such a floorplan.

This can be solved by setting a lower utilization value. You will find out that
about 5% utilization is needed for the floorplan to succeed. This is controlled
by `FP_CORE_UTIL` {py:class}`Variable <openlane.config.Variable>`.

Update the configuration as follows:

```json
{
  "DESIGN_NAME": "user_project_wrapper",
  "CLOCK_PERIOD": 25,
  "CLOCK_PORT": "wb_clk_i",
  "VERILOG_FILES": [
    "dir::./defines.v",
    "dir::./SPM_example.v",
    "dir::./user_project_wrapper.v"
  ],
  "FP_CORE_UTIL": 5
}
```

Then run the flow again:

```console
[nix-shell:~/openlane2]$ openlane ~/my_designs/spm-user_project_wrapper/config.json
```

#### Examining the results

Let's view the layout:

```console
[nix-shell:~/openlane2]$ openlane --last-run --flow openinklayout ~/my_designs/spm-user_project_wrapper/config.json
```

```{figure} ./spm-caravel-user-project-util.png

SPM with 5% utilization
```

```{tip}
You can control the visible layers in KLayout by right-clicking in the
layers area and selecting hide all layers. Then double click on the layers that
you want to view. In this figure, only `met2.pin`, `met3.pin`, and
`prBoundary.boundary` are shown.
```

As shown above, there are a lot of pins needed by the design and certainly, a
floorplan with 50% utilization wouldn't fit all the pins.

---

#### Caravel Integration

Caravel User Project is a macro inside Caravel. To be able to use
any design as a Caravel User Project, it has to match the footprint
that Caravel is expecting so we can't rely on `FP_CORE_UTIL`.

##### IO Pins

The top-level design Caravel is expecting any Caravel User Project
to have the IO pins at specific locations and with specific dimensions. We can
achieve that by using the variable `FP_DEF_TEMPLATE`. `FP_DEF_TEMPLATE` is a
`DEF` file that is used as a template for the design's floorplan. IOs pin shapes
and locations are copied from the template DEF file over to our design. In
addition, the same die area is used as the one in the template DEF file.

Save this file
[template.def](../../../../openlane/examples/spm-user_project_wrapper/template.def),
in your design's directory which should be
`~/my_designs/spm-user_project_wrapper/`. Then update the design's configuration
by adding `FP_DEF_TEMPLATE` variable:

```json
{
  "DESIGN_NAME": "user_project_wrapper",
  "VERILOG_FILES": ["dir::./defines.v", "dir::./SPM_example.v"],
  "CLOCK_PERIOD": 25,
  "CLOCK_PORT": "wb_clk_i",
  "FP_DEF_TEMPLATE": "dir::./template.def",
  "FP_SIZING": "absolute",
  "DIE_AREA": [0, 0, 2920, 3520]
}
```

##### Power Distribution Network (PDN)

A macro's Power Distribution Network (`PDN`) is responsible for the delivery of
power to cells in the design. A macro's internal PDN is exposed through pins
as an interface for integration with other designs. These pins are similar to
data IO pins but often much larger.

Here is another example of a macro that is fully integrated inside Caravel:

```{figure} ./caravel-1.png
:align: center

Example of a macro integrated inside Caravel
```

This figure displays Caravel chip. The highlighted rectangle is where
Caravel User Project is. Let's zoom in at the top right corner of this
area.

```{figure} ./caravel-pdn-2.png
:align: center

Top right corner of macro integrated inside Caravel
```

As highlighted there are power rings surrounding our wrapper. connectivity
between the wrapper rings and the chip is done through the highlighted light
blue `met3` wires.

Our `PDN` of Caravel User Project has to be configured to look like
the figure shown above. This is done by using a collection of variables that are
responsible for controlling the shape, location, and metal layers of the `PDN`
pins offering the power interface of the macro.

Let's add these variables to our configuration file:

```json
{
  "DESIGN_NAME": "user_project_wrapper",
  "VERILOG_FILES": ["dir::./defines.v", "dir::./SPM_example.v"],
  "CLOCK_PERIOD": 25,
  "CLOCK_PORT": "wb_clk_i",
  "FP_DEF_TEMPLATE": "dir::./template.def",
  "FP_SIZING": "absolute",
  "DIE_AREA": [0, 0, 2920, 3520],
  "FP_PDN_CORE_RING": 1,
  "FP_PDN_CORE_RING_VWIDTH": 3.1,
  "FP_PDN_CORE_RING_HWIDTH": 3.1,
  "FP_PDN_CORE_RING_VOFFSET": 12.45,
  "FP_PDN_CORE_RING_HOFFSET": 12.45,
  "FP_PDN_CORE_RING_VSPACING": 1.7,
  "FP_PDN_CORE_RING_HSPACING": 1.7,
  "FP_PDN_VWIDTH": 3.1,
  "FP_PDN_HWIDTH": 3.1,
  "FP_PDN_VSPACING": "expr::(5 * $FP_PDN_CORE_RING_VWIDTH)",
  "FP_PDN_HSPACING": "expr::(5 * $FP_PDN_CORE_RING_HWIDTH)"
}
```

```{seealso}
Visit {step}`OpenROAD.GeneratePDN` for more information about each
of the above variables.
```

Caravel is a chip with multiple power domains. We need to match these domains
in our configuration by adding `VDD_NETS` and `GND_NETS` variables:

```json
{
  "DESIGN_NAME": "user_project_wrapper",
  "VERILOG_FILES": ["dir::./defines.v", "dir::./SPM_example.v"],
  "CLOCK_PERIOD": 25,
  "CLOCK_PORT": "wb_clk_i",
  "FP_DEF_TEMPLATE": "dir::./template.def",
  "FP_SIZING": "absolute",
  "DIE_AREA": [0, 0, 2920, 3520],
  "FP_PDN_CORE_RING": 1,
  "FP_PDN_CORE_RING_VWIDTH": 3.1,
  "FP_PDN_CORE_RING_HWIDTH": 3.1,
  "FP_PDN_CORE_RING_VOFFSET": 12.45,
  "FP_PDN_CORE_RING_HOFFSET": 12.45,
  "FP_PDN_CORE_RING_VSPACING": 1.7,
  "FP_PDN_CORE_RING_HSPACING": 1.7,
  "FP_PDN_VWIDTH": 3.1,
  "FP_PDN_HWIDTH": 3.1,
  "FP_PDN_VSPACING": "expr::(5 * $FP_PDN_CORE_RING_VWIDTH)",
  "FP_PDN_HSPACING": "expr::(5 * $FP_PDN_CORE_RING_HWIDTH)",
  "VDD_NETS": ["vccd1", "vccd2", "vdda1", "vdda2"],
  "GND_NETS": ["vssd1", "vssd2", "vssa1", "vssa2"]
}
```

##### Timing Constraints

```{admonition} STA and timing closure guide
:class: important

It is highly recommended that you read the
[STA and timing closure guide](https://docs.google.com/document/d/13J1AY1zhzxur8vaFs3rRW9ZWX113rSDs63LezOOoXZ8/)
to fully understand this section.
```

Finally, to achieve a timing-clean Caravel User Project design integrated into
Caravel, it is crucial to satisfy specific timing constraints at the boundary
I/Os. The provided Caravel User Project
[SDC file](../../../../openlane/examples/spm-user_project_wrapper/base_sdc_file.sdc)
guides the tools to ensure proper timing performance of the design interfacing
with Caravel. The SDC file mainly defines:

1. Clock Network:

   Specifying clock characteristics and effects such as:

   - Primary clock port and period
   - Clock uncertainty, transition, and latency.

1. Design rules:

   Specifying the maximum limit for transition time and for fanout. The tools
   apply the minimum of the limits set by the technology libraries and the
   SDC.

1. I/O timing constraints:

   Specifying the expected delay range for signals to arrive at inputs and to be
   valid at the outputs. As well as, the inputs transition time ranges and
   expected loads on the outputs.

1. Timing exceptions:

   By default, the tools assume that data launched at a path startpoint is
   captured at all path endpoints within one clock cycle. Whenever a path is not
   intended to operate in this manner, a timing exception should be defined such
   as:

   - False paths: specifies paths that are not required to be analyzed.
   - Multicycle paths: specifies the required number of clock cycles to
     propagate the data for certain paths rather than the default one clock
     cycle.

   In Caravel User Project SDC file, it specifies that some ports require 2
   clock cycles which relaxes the setup constraints on these ports and hence
   avoids over-optimizations.

1. On-chip Variations:

   To model {term}`On-chip variation` effects, a derate factor is applied to
   specify the margin on all delays. A typical value for `sky130` is `5%`.

```{admonition} Static Timing Analysis on Caravel *and* Caravel User Project
:class: tip

A final STA check with the Caravel User Project integrated into Caravel is
required to achieve timing closure. While having a successful flow run without
any timing violations indicates that almost certainly the design is
timing-clean, this final combined simulation ensures that.
```

Download
[this SDC file](../../../../openlane/examples/spm-user_project_wrapper/base_sdc_file.sdc),
and place it in our design directory `~/my_design/spm-user_project_wrapper/`.
Then set the variables {var}`OpenROAD.STAPostPNR::SIGNOFF_SDC_FILE` and
{var}`OpenROAD.STAPostPNR::PNR_SDC_FILE` to point to the downloaded file to be
able to apply these constraints during implementation and signoff while running
the flow. Our final configuration looks like this:

```json
{
  "DESIGN_NAME": "user_project_wrapper",
  "VERILOG_FILES": ["dir::./defines.v", "dir::./SPM_example.v"],
  "CLOCK_PERIOD": 25,
  "CLOCK_PORT": "wb_clk_i",
  "FP_DEF_TEMPLATE": "dir::./template.def",
  "FP_SIZING": "absolute",
  "DIE_AREA": [0, 0, 2920, 3520],
  "FP_PDN_CORE_RING": 1,
  "FP_PDN_CORE_RING_VWIDTH": 3.1,
  "FP_PDN_CORE_RING_HWIDTH": 3.1,
  "FP_PDN_CORE_RING_VOFFSET": 12.45,
  "FP_PDN_CORE_RING_HOFFSET": 12.45,
  "FP_PDN_CORE_RING_VSPACING": 1.7,
  "FP_PDN_CORE_RING_HSPACING": 1.7,
  "FP_PDN_VWIDTH": 3.1,
  "FP_PDN_HWIDTH": 3.1,
  "FP_PDN_VSPACING": "expr::(5 * $FP_PDN_CORE_RING_VWIDTH)",
  "FP_PDN_HSPACING": "expr::(5 * $FP_PDN_CORE_RING_HWIDTH)",
  "VDD_NETS": ["vccd1", "vccd2", "vdda1", "vdda2"],
  "GND_NETS": ["vssd1", "vssd2", "vssa1", "vssa2"],
  "PNR_SDC_FILE": "dir::./base_sdc_file.sdc",
  "SIGNOFF_SDC_FILE": "dir::./base_sdc_file.sdc"
}
```
